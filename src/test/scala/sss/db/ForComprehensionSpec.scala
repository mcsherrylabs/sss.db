package sss.db

//@DoNotDiscover
class ForComprehensionSpec extends DbSpecSetup {


  "A paged view " should "support a paged stream generator " in {

    val rows = for {
      x <- (0 until 10)
      _ = fixture.dbUnderTest.table("testForComp").insert(x, x+1, "strId" + x)
      //rs: Rows <- (fixture.dbUnderTest.table("testForComp").toPaged(15))
      rs: Rows <- (fixture.dbUnderTest.table("testForComp").toPaged(2)).toStream
      r        <- rs
      if(r[Int](idCol) == 1)
    } yield(r)

    assert(rows.size === 10, "Should be 10 rows!")

  }

  it should " support generator (thru IndexedSeq) " in {
    val tableNames = for {
      index <- (0 until 10)
      blockSql = (s"CREATE TABLE IF NOT EXISTS block_$index " +
        s"(id INT GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1), " +
        s"$statusCol VARCHAR(50), " +
        s"PRIMARY KEY(id)) ")

      _ = fixture.dbUnderTest.executeSql(blockSql)
    } yield(s"block_$index")

    for {
      name <- tableNames
      table = fixture.dbUnderTest.table(name)
      x <- (0 until 10)
      _ = table.insert(Map(statusCol -> s"Something $name"))
    } yield()

    val allRows = for {
      name <- tableNames
      table = fixture.dbUnderTest.table(name)
      rows <- table.toPaged(3).toIterator
      row  <- rows
      if(row[Int](idCol) == 5)
    } yield (row)

    //allRows.foreach(println)
  }

  it should " support nested generator (thru IndexedSeq) " in {
    val tableNames = for {
      index <- (0 until 10)
      blockSql = (s"CREATE TABLE IF NOT EXISTS block_$index " +
        s"(id INT GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1), " +
        s"$statusCol VARCHAR(50), " +
        s"PRIMARY KEY(id)) ")

      _ = fixture.dbUnderTest.executeSql(blockSql)
    } yield(s"block_$index")

    for {
      name <- tableNames
      table = fixture.dbUnderTest.table(name)
      x <- (0 until 10)
      _ = table.insert(Map(statusCol -> s"Something $name"))
    } yield()

    case class Domain(r1: Row, r2: Row)

    val allRows = for {
      name <- tableNames
      table = fixture.dbUnderTest.table(name)
      row <- table
      row2 <- fixture.dbUnderTest.table(name)
      if(row[Int](idCol) == 7)
      if(row2[Int](idCol) == 7)
    } yield (Domain(row, row2))

    type fm = Row => Query //= r => fixture.dbUnderTest.table("name")

    val f : fm = r1 => fixture.dbUnderTest.table("block_1")

    fixture.dbUnderTest.table("block_1").flatMap(f)

    fixture.dbUnderTest.table("block_2").flatMap(f).map(r2 =>
        r2.map(r => Domain(r,r)))


    /*(0).to(100).flatMap[Int, IndexedSeq[Int]](
      ((i: Int) => (i).to(3).map[Int, IndexedSeq[Int]](
        ((j: Int) => (i+j))))*/
    //allRows.filter(p => p.isNotEmpty).foreach(println)
  }

}