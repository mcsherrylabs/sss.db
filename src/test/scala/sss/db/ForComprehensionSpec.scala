package sss.db

import org.scalatest.DoNotDiscover

import scala.util.Try

@DoNotDiscover
class ForComprehensionSpec extends DbSpecSetup {


  "A paged view " should "support a paged stream generator " in {

    val rows = for {
      x <- (0 until 10)
      _ = fixture.dbUnderTest.table("testForComp").insert(x, x+1, "strId" + x)
      rs: Rows <- (fixture.dbUnderTest.table("testForComp").toPaged(2)).to(LazyList)
      r        <- rs
      if(r[Int](idCol) == 1)
    } yield(r)

    assert(rows.size === 10, "Should be 10 rows!")

  }

  def createAndFillTenTables: Seq[String] = {
    //create 10 tables
    val tableNames = for {
      index <- (0 until 10)
      blockSql = (s"CREATE TABLE IF NOT EXISTS block_$index " +
        s"(id INT GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1), " +
        s"$statusCol VARCHAR(50), " +
        s"PRIMARY KEY(id)) ")

      _ = fixture.dbUnderTest.executeSql(blockSql)
    } yield(s"block_$index")

    //put 10 lines in each table = 100 rows
    for {
      name <- tableNames
      table = fixture.dbUnderTest.table(name)
      x <- (0 until 10)
      _ = table.insert(Map(statusCol -> s"Something $name"))
    } yield()

    tableNames
  }

  it should " support paged iterator generator " in {

    val tableNames = createAndFillTenTables
    // go through each table in a paged manner and find all the rows
    // where the idCol is 1 or 9, should be 20 of them.
    val allRows = for {
      name <- tableNames
      table = fixture.dbUnderTest.table(name)
      rows <- table.toPaged(3).iterator
      row <- rows
      if (row[Int](idCol) == 1 || row[Int](idCol) == 9)
    } yield (row)

    //allRows.foreach(println)
    assert(allRows.size === 20)

    val checked = for {
      r <- allRows
      if (r[Int](idCol) != 1 && r[Int](idCol) != 9)
    } yield (r)
    assert(checked.size === 0)
  }

  it should " support paged iterable generator " in {
    val tableNames = createAndFillTenTables
    val allRows = for {
      name <- tableNames
      table = fixture.dbUnderTest.table(name)
      rows <- table.toPaged(3)
      row  <- rows
      if(row[Int](idCol) == 1 || row[Int](idCol) == 9)
    } yield (row)

    //allRows.foreach(println)
    assert(allRows.size === 20)
  }

  it should " support commit in transactions using Try " in {

    val x = 1000
    val t = fixture.dbUnderTest.table("testForComp")

    import t.tx

    def goodTx2(r: Int): Try[Int] = Try(t.insert(r, r + 1, "strId" + r))

    def goodTx1: Try[Int] = Try(t.insert(x, x + 1, "strId" + x))

    val result: Try[Int] = tx {
      for {
        v1 <- goodTx1
        v2 <- goodTx2(x + v1)
      } yield (v2)
    }

    assert(result.isSuccess)
    assert(result.get == 1, "Should only insert 1 row")
    assert(t.find(where(idCol -> x)).isDefined, "tx should have committed ")
    assert(t.find(where(idCol -> (x + 1))).isDefined, "tx should have committed second write also")

  }

  it should " support rollback in transactions using Try " in {

    val x = 1000
    val t = fixture.dbUnderTest.table("testForComp")

    import t.tx

    def badTx(r: Int): Try[Int] = Try {
      assert(r == x + 1)
      throw new RuntimeException("Woh!")
    }

    def goodTx: Try[Int] = Try(t.insert(x, x + 1, "strId" + x))

    val result: Try[Int] = tx {
      for {
        v1 <- goodTx
        v2 <- badTx(v1)
      } yield (v2)
    }
    assert(result.isFailure, "Should have thrown exception in badTx")
    assert(t.find(where(idCol -> x)).isEmpty, "tx rollback should have prevented row write")

  }



  it should " support nested generator (thru flatMap) " in {
    val tableNames = createAndFillTenTables
    val allRows = for {
      name <- tableNames
      table = fixture.dbUnderTest.table(name)
      row <- table
      row2 <- fixture.dbUnderTest.table(name)
    } yield ((row, row2))

    assert(allRows.size === 1000)

    val allRowsFiltered = for {
      name <- tableNames
      table = fixture.dbUnderTest.table(name)
      row <- table
      row2 <- fixture.dbUnderTest.table(name)
      if(row[Int](idCol) == row2[Int](idCol))
    } yield ((row, row2))

    assert(allRowsFiltered.size === 100)
    //allRowsFiltered.foreach(println)

  }

}